<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>2栈和队列s on My New Hugo Site</title>
    <link>http://shrouded-inlet-85726.herokuapp.com/2%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</link>
    <description>Recent content in 2栈和队列s on My New Hugo Site</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="http://shrouded-inlet-85726.herokuapp.com/2%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>栈和队列</title>
      <link>http://shrouded-inlet-85726.herokuapp.com/2%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://shrouded-inlet-85726.herokuapp.com/2%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</guid>
      <description>

&lt;h3 id=&#34;chapter-2:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Chapter 2&lt;/h3&gt;

&lt;h1 id=&#34;栈和队列:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;栈和队列&lt;/h1&gt;

&lt;p&gt;栈是一种特殊的表，其只能在表的末端进行插入和删除，因此也为称为LIFO(后进先出)表，常用的实现方式包括数组实现和链表实现。
队列也是一种特殊的表，使用队列时插入在一端进行而删除在另一端，所以是FIFO(先进先出)表。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>栈</title>
      <link>http://shrouded-inlet-85726.herokuapp.com/2%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/stack/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://shrouded-inlet-85726.herokuapp.com/2%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/stack/</guid>
      <description>&lt;p&gt;这里我们只是简单实现一下栈的api,在不考虑性能的情况下，用python的list完全可以实现&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Stack:
    def __init__(self,datas=[]):
        self.datas = datas

    def __len__(self):
        return len(self.datas)

    def isEmpty(self):
        return len(self) == 0

    def push(self,data):
        self.datas.append(data)

    def pop(self):
        return self.datas.pop() if not self.isEmpty() else None

    def peek(self):
        return self[len(self.datas)-1] if not self.isEmpty() else None

    def __getitem__(self,i):
        return self.datas[i]

    def __setitem__(self,i,y):
        self.datas[i] = y
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>队列</title>
      <link>http://shrouded-inlet-85726.herokuapp.com/2%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/queue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://shrouded-inlet-85726.herokuapp.com/2%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/queue/</guid>
      <description>

&lt;p&gt;这里我们只是简单实现一下队列的api,在不考虑性能的情况下，用python的list完全可以实现&lt;/p&gt;

&lt;h2 id=&#34;简单队列:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;简单队列&lt;/h2&gt;

&lt;p&gt;队列主要的api包括入队，出队，以及查看队首元素&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Queue:
    def __init__(self,datas=[]):
        self.datas = datas

    def __len__(self):
        return len(self.datas)

    def isEmpty(self):
        return len(self) == 0

    def enqueue(self, data):
        self.datas.append(data)

    def dequeue(self):
        return self.datas.pop(0) if not self.isEmpty() else None

    def peek(self):
        return self[0] if not self.isEmpty() else None

    def __getitem__(self,i):
        return self.datas[i]

    def __setitem__(self,i,y):
        self.datas[i] = y
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;双端队列:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;双端队列&lt;/h2&gt;

&lt;p&gt;和简单队列不同的是，双端队列两边都可以插入和删除。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Deque:
    def __init__(self,datas=[]):
        self.datas = datas

    def __len__(self):
    	return len(self.datas)

    def isEmpty(self):
    	return len(self) == 0

    def enqueue(self, data):
        self.datas.append(data)

    def dequeue(self):
        return self.datas.pop(0) if not self.isEmpty() else None

    def enqueueFront(self, data):
        self.datas.insert(0, data)

    def dequeueBack(self):
        return self.datas.pop() if not self.isEmpty() else None

    def peekFront(self):
        return self[0] if not self.isEmpty() else None

    def peekBack(self):
    	return self[len(self)-1]  if not self.isEmpty() else None

    def __getitem__(self,i):
    	return self.datas[i]

    def __setitem__(self,i,y):
    	self.datas[i] = y
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>常见问题</title>
      <link>http://shrouded-inlet-85726.herokuapp.com/2%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/commonquestion/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://shrouded-inlet-85726.herokuapp.com/2%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/commonquestion/</guid>
      <description></description>
    </item>
    
  </channel>
</rss>